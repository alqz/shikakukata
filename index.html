<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Shikakukata — Shikaku Puzzle</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #1a1a2e;
    --surface: #16213e;
    --border: #0f3460;
    --text: #e0e0e0;
    --text-dim: #8888aa;
    --accent: #e94560;
    --cell-size: 52px;
    --cell-font: 1.1rem;
    --grid-gap: 1px;
  }

  body {
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 24px 16px;
    user-select: none;
  }

  h1 {
    font-size: 1.8rem;
    font-weight: 300;
    letter-spacing: 0.15em;
    margin-bottom: 4px;
    color: var(--accent);
  }

  .subtitle {
    font-size: 0.85rem;
    color: var(--text-dim);
    margin-bottom: 20px;
  }

  .controls {
    display: flex;
    gap: 10px;
    margin-bottom: 16px;
    flex-wrap: wrap;
    justify-content: center;
  }

  button {
    background: var(--surface);
    color: var(--text);
    border: 1px solid var(--border);
    padding: 8px 18px;
    border-radius: 6px;
    font-size: 0.9rem;
    cursor: pointer;
    transition: all 0.15s;
  }

  button:hover { background: var(--border); }
  button:active { transform: scale(0.97); }
  button.active { border-color: var(--accent); color: var(--accent); }

  .size-controls {
    display: flex;
    gap: 6px;
    align-items: center;
  }

  .size-controls span {
    font-size: 0.85rem;
    color: var(--text-dim);
    min-width: 42px;
    text-align: center;
  }

  .status {
    font-size: 0.9rem;
    margin-bottom: 12px;
    min-height: 1.4em;
    color: var(--text-dim);
  }

  .status.win { color: #4ecdc4; font-weight: 600; }
  .status.error { color: var(--accent); }

  #grid-container {
    position: relative;
    margin-bottom: 20px;
  }

  #grid {
    display: grid;
    background: #0a0a1a;
    gap: var(--grid-gap);
    border: 2px solid var(--border);
    border-radius: 4px;
    overflow: hidden;
  }

  .cell {
    width: var(--cell-size);
    height: var(--cell-size);
    background: var(--surface);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: var(--cell-font);
    font-weight: 600;
    position: relative;
    cursor: crosshair;
    transition: background 0.1s;
  }

  .cell.clue { color: #fff; }
  .cell.empty { color: transparent; }
  .cell.selecting { background: rgba(233, 69, 96, 0.25); }

  /* Edit mode: cells are clickable inputs */
  .cell.editable {
    cursor: pointer;
    color: #f7dc6f;
  }
  .cell.editable:hover { background: rgba(247, 220, 111, 0.15); }

  .rect-overlay {
    position: absolute;
    border: 2.5px solid;
    border-radius: 3px;
    pointer-events: none;
    z-index: 10;
    transition: opacity 0.2s;
  }

  .rect-overlay.invalid {
    background: rgba(233, 69, 96, 0.1);
    border-style: dashed;
  }

  .instructions {
    max-width: 520px;
    text-align: center;
    font-size: 0.82rem;
    color: var(--text-dim);
    line-height: 1.6;
    margin-top: 8px;
  }

  .instructions strong { color: var(--text); }

  .timer {
    font-size: 0.85rem;
    color: var(--text-dim);
    margin-bottom: 8px;
    font-variant-numeric: tabular-nums;
  }

  /* Custom puzzle modal */
  .modal-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.7);
    z-index: 100;
    align-items: center;
    justify-content: center;
  }
  .modal-overlay.visible { display: flex; }

  .modal {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 24px;
    max-width: 500px;
    width: 90%;
  }

  .modal h2 {
    font-size: 1.1rem;
    font-weight: 500;
    margin-bottom: 12px;
    color: var(--text);
  }

  .modal p {
    font-size: 0.82rem;
    color: var(--text-dim);
    margin-bottom: 12px;
    line-height: 1.5;
  }

  .modal textarea {
    width: 100%;
    height: 160px;
    background: var(--bg);
    color: var(--text);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 10px;
    font-family: 'SF Mono', 'Fira Code', monospace;
    font-size: 0.85rem;
    resize: vertical;
    margin-bottom: 12px;
  }

  .modal textarea:focus { outline: 1px solid var(--accent); }

  .modal .modal-buttons {
    display: flex;
    gap: 8px;
    justify-content: flex-end;
  }

  .modal .error-msg {
    color: var(--accent);
    font-size: 0.82rem;
    margin-bottom: 8px;
    min-height: 1.2em;
  }

  @media (max-width: 500px) {
    :root { --cell-size: 40px; --cell-font: 0.9rem; }
    h1 { font-size: 1.4rem; }
  }
</style>
</head>
<body>

<h1>SHIKAKUKATA</h1>
<p class="subtitle">Shikaku Puzzle Game</p>

<div class="controls">
  <div class="size-controls">
    <button id="btn-smaller">&minus;</button>
    <span id="size-label">5&times;5</span>
    <button id="btn-larger">+</button>
  </div>
  <button id="btn-new">New Puzzle</button>
  <button id="btn-custom">Custom</button>
  <button id="btn-undo">Undo</button>
  <button id="btn-clear">Clear</button>
  <button id="btn-solve">Solve</button>
</div>

<div class="timer" id="timer">0:00</div>
<div class="status" id="status">Drag to draw rectangles. Each must contain exactly one number equal to its area.</div>

<div id="grid-container">
  <div id="grid"></div>
</div>

<div class="instructions">
  <strong>How to play:</strong> Click and drag to draw a rectangle.
  Each rectangle must contain exactly <strong>one number</strong>,
  and that number must equal the rectangle's <strong>area</strong>.
  Cover every cell to win. Use <strong>Custom</strong> to enter your own puzzle.
</div>

<!-- Custom puzzle modal -->
<div class="modal-overlay" id="modal-overlay">
  <div class="modal">
    <h2>Enter Custom Puzzle</h2>
    <p>
      Enter numbers separated by spaces, one row per line.
      Use <strong>0</strong> for empty cells. All rows must have the same length,
      and the clue values must sum to the total grid area.
    </p>
    <textarea id="custom-input" spellcheck="false" placeholder="0 6 0 0 4
0 0 0 0 0
0 0 5 0 0
4 0 0 0 0
0 0 0 6 0"></textarea>
    <div class="error-msg" id="custom-error"></div>
    <div class="modal-buttons">
      <button id="btn-custom-cancel">Cancel</button>
      <button id="btn-custom-load">Load &amp; Solve</button>
      <button id="btn-custom-play">Load &amp; Play</button>
    </div>
  </div>
</div>

<script>
// ─── Shikaku Solver ────────────────────────────────────────────────

function solveShikaku(grid) {
  const rows = grid.length;
  const cols = grid[0].length;
  const totalArea = rows * cols;

  const clues = [];
  for (let r = 0; r < rows; r++)
    for (let c = 0; c < cols; c++)
      if (grid[r][c] > 0) clues.push([r, c, grid[r][c]]);

  const clueSum = clues.reduce((s, cl) => s + cl[2], 0);
  if (clueSum !== totalArea) return null;

  const covered = Array.from({ length: rows }, () => new Int8Array(cols).fill(-1));

  function getRectangles(cr, cc, area) {
    const rects = [];
    for (let h = 1; h <= area; h++) {
      if (area % h !== 0) continue;
      const w = area / h;
      for (let r1 = cr - h + 1; r1 <= cr; r1++) {
        for (let c1 = cc - w + 1; c1 <= cc; c1++) {
          const r2 = r1 + h - 1;
          const c2 = c1 + w - 1;
          if (r1 >= 0 && r2 < rows && c1 >= 0 && c2 < cols)
            rects.push([r1, c1, r2, c2]);
        }
      }
    }
    return rects;
  }

  const allRects = clues.map(([cr, cc, val]) => getRectangles(cr, cc, val));

  // MRV: sort by fewest rectangles
  const order = [...Array(clues.length).keys()].sort((a, b) => allRects[a].length - allRects[b].length);
  const sortedClues = order.map(i => clues[i]);
  const sortedRects = order.map(i => allRects[i]);

  function rectIsFree(r1, c1, r2, c2) {
    for (let r = r1; r <= r2; r++)
      for (let c = c1; c <= c2; c++)
        if (covered[r][c] !== -1) return false;
    return true;
  }

  function hasOtherClue(r1, c1, r2, c2, idx) {
    for (let i = 0; i < sortedClues.length; i++) {
      if (i === idx) continue;
      const [cr, cc] = sortedClues[i];
      if (cr >= r1 && cr <= r2 && cc >= c1 && cc <= c2) return true;
    }
    return false;
  }

  function place(r1, c1, r2, c2, idx) {
    for (let r = r1; r <= r2; r++)
      for (let c = c1; c <= c2; c++)
        covered[r][c] = idx;
  }

  function unplace(r1, c1, r2, c2) {
    for (let r = r1; r <= r2; r++)
      for (let c = c1; c <= c2; c++)
        covered[r][c] = -1;
  }

  const solution = new Array(sortedClues.length).fill(null);

  function backtrack(idx) {
    if (idx === sortedClues.length) {
      for (let r = 0; r < rows; r++)
        for (let c = 0; c < cols; c++)
          if (covered[r][c] === -1) return false;
      return true;
    }

    const [cr, cc] = sortedClues[idx];
    if (covered[cr][cc] !== -1) return false;

    for (const rect of sortedRects[idx]) {
      const [r1, c1, r2, c2] = rect;
      if (rectIsFree(r1, c1, r2, c2) && !hasOtherClue(r1, c1, r2, c2, idx)) {
        place(r1, c1, r2, c2, idx);
        solution[idx] = rect;
        if (backtrack(idx + 1)) return true;
        unplace(r1, c1, r2, c2);
        solution[idx] = null;
      }
    }
    return false;
  }

  if (backtrack(0)) {
    const result = [];
    for (let i = 0; i < sortedClues.length; i++) {
      result.push({ clue: sortedClues[i], rect: solution[i] });
    }
    return result;
  }
  return null;
}

// ─── Puzzle Diagnostics ────────────────────────────────────────────

function diagnosePuzzle(grid) {
  const rows = grid.length;
  const cols = grid[0].length;
  const totalArea = rows * cols;
  const reasons = [];

  // Collect clues
  const clues = [];
  for (let r = 0; r < rows; r++)
    for (let c = 0; c < cols; c++)
      if (grid[r][c] > 0) clues.push([r, c, grid[r][c]]);

  if (clues.length === 0) {
    reasons.push('The grid has no clues at all.');
    return reasons;
  }

  // Check clue sum
  const clueSum = clues.reduce((s, cl) => s + cl[2], 0);
  if (clueSum !== totalArea) {
    reasons.push(`Clue sum (${clueSum}) does not equal grid area (${totalArea}).`);
    return reasons;
  }

  // For each clue, find all valid rectangles (no out-of-bounds)
  function getRectangles(cr, cc, area) {
    const rects = [];
    for (let h = 1; h <= area; h++) {
      if (area % h !== 0) continue;
      const w = area / h;
      for (let r1 = cr - h + 1; r1 <= cr; r1++) {
        for (let c1 = cc - w + 1; c1 <= cc; c1++) {
          const r2 = r1 + h - 1;
          const c2 = c1 + w - 1;
          if (r1 >= 0 && r2 < rows && c1 >= 0 && c2 < cols)
            rects.push([r1, c1, r2, c2]);
        }
      }
    }
    return rects;
  }

  // Check each clue for obvious issues
  for (const [cr, cc, val] of clues) {
    // Clue too large for entire grid
    if (val > totalArea) {
      reasons.push(`Clue ${val} at (${cr + 1},${cc + 1}) exceeds the grid area (${totalArea}).`);
      continue;
    }

    const rects = getRectangles(cr, cc, val);
    if (rects.length === 0) {
      reasons.push(`Clue ${val} at (${cr + 1},${cc + 1}) has no possible rectangle that fits on the grid.`);
      continue;
    }

    // Filter out rects that contain other clues
    const validRects = rects.filter(([r1, c1, r2, c2]) => {
      for (const [ocr, occ, _] of clues) {
        if (ocr === cr && occ === cc) continue;
        if (ocr >= r1 && ocr <= r2 && occ >= c1 && occ <= c2) return false;
      }
      return true;
    });

    if (validRects.length === 0) {
      reasons.push(`Clue ${val} at (${cr + 1},${cc + 1}): every possible rectangle contains another clue.`);
    }
  }

  // Check for cells unreachable by any clue
  const reachable = Array.from({ length: rows }, () => new Uint8Array(cols));
  for (const [cr, cc, val] of clues) {
    const rects = getRectangles(cr, cc, val);
    for (const [r1, c1, r2, c2] of rects) {
      for (let r = r1; r <= r2; r++)
        for (let c = c1; c <= c2; c++)
          reachable[r][c] = 1;
    }
  }
  const unreachableCells = [];
  for (let r = 0; r < rows; r++)
    for (let c = 0; c < cols; c++)
      if (!reachable[r][c]) unreachableCells.push(`(${r + 1},${c + 1})`);

  if (unreachableCells.length > 0) {
    const shown = unreachableCells.length <= 5
      ? unreachableCells.join(', ')
      : unreachableCells.slice(0, 5).join(', ') + ` and ${unreachableCells.length - 5} more`;
    reasons.push(`${unreachableCells.length} cell(s) cannot be reached by any clue's rectangle: ${shown}.`);
  }

  // Check for adjacent clues that are both 1 (impossible — overlap)
  for (let i = 0; i < clues.length; i++) {
    for (let j = i + 1; j < clues.length; j++) {
      const [r1, c1, v1] = clues[i];
      const [r2, c2, v2] = clues[j];
      if (v1 === 1 && v2 === 1 && Math.abs(r1 - r2) + Math.abs(c1 - c2) === 1) {
        reasons.push(`Two adjacent clues of 1 at (${r1 + 1},${c1 + 1}) and (${r2 + 1},${c2 + 1}) — both need a 1x1 rectangle, leaving the other's cell uncoverable.`);
      }
    }
  }

  if (reasons.length === 0) {
    reasons.push('No obvious structural issue found; the puzzle is valid but the backtracking search found no solution (conflicting constraints).');
  }

  return reasons;
}

// ─── Puzzle Generator ──────────────────────────────────────────────

function generatePuzzle(rows, cols) {
  const grid = Array.from({ length: rows }, () => new Array(cols).fill(0));
  const used = Array.from({ length: rows }, () => new Uint8Array(cols));
  const rects = [];

  function findFirstEmpty() {
    for (let r = 0; r < rows; r++)
      for (let c = 0; c < cols; c++)
        if (!used[r][c]) return [r, c];
    return null;
  }

  function canPlace(r1, c1, r2, c2) {
    if (r2 >= rows || c2 >= cols) return false;
    for (let r = r1; r <= r2; r++)
      for (let c = c1; c <= c2; c++)
        if (used[r][c]) return false;
    return true;
  }

  function markUsed(r1, c1, r2, c2) {
    for (let r = r1; r <= r2; r++)
      for (let c = c1; c <= c2; c++)
        used[r][c] = 1;
  }

  const maxDim = Math.min(8, Math.max(rows, cols));

  while (true) {
    const cell = findFirstEmpty();
    if (!cell) break;
    const [r, c] = cell;

    const maxArea = Math.min(rows * cols - rects.reduce((s, rc) => s + (rc[2] - rc[0] + 1) * (rc[3] - rc[1] + 1), 0), rows * cols);
    const candidates = [];

    for (let h = 1; h <= Math.min(rows - r, maxDim); h++) {
      for (let w = 1; w <= Math.min(cols - c, maxDim); w++) {
        const area = h * w;
        if (area > 0 && area <= Math.min(maxArea, rows + cols) && canPlace(r, c, r + h - 1, c + w - 1)) {
          candidates.push([r, c, r + h - 1, c + w - 1]);
        }
      }
    }

    if (candidates.length === 0) {
      if (!used[r][c]) {
        used[r][c] = 1;
        rects.push([r, c, r, c]);
      }
      continue;
    }

    candidates.sort(() => Math.random() - 0.5);
    const weighted = candidates.filter(([r1, c1, r2, c2]) => {
      const a = (r2 - r1 + 1) * (c2 - c1 + 1);
      return a >= 2 && a <= Math.max(6, Math.floor(rows * cols / 4));
    });

    const chosen = (weighted.length > 0 ? weighted : candidates)[0];
    markUsed(...chosen);
    rects.push(chosen);
  }

  for (const [r1, c1, r2, c2] of rects) {
    const area = (r2 - r1 + 1) * (c2 - c1 + 1);
    const cells = [];
    for (let r = r1; r <= r2; r++)
      for (let c = c1; c <= c2; c++)
        cells.push([r, c]);
    const [cr, cc] = cells[Math.floor(Math.random() * cells.length)];
    grid[cr][cc] = area;
  }

  return grid;
}

// ─── Game State ────────────────────────────────────────────────────

const COLORS = [
  '#e94560', '#4ecdc4', '#f7dc6f', '#a29bfe', '#fd79a8',
  '#00b894', '#6c5ce7', '#fdcb6e', '#e17055', '#74b9ff',
  '#55efc4', '#fab1a0', '#81ecec', '#dfe6e9', '#b2bec3',
  '#636e72', '#d63031', '#0984e3', '#e84393', '#00cec9',
  '#2d3436', '#ffeaa7', '#ff7675', '#a4b0be', '#f5cd79',
];

let gridSize = 5;
let grid = [];
let playerRects = [];
let undoStack = [];
let dragStart = null;
let dragEnd = null;
let isDragging = false;
let timerStart = null;
let timerInterval = null;
let solved = false;

const gridEl = document.getElementById('grid');
const gridContainer = document.getElementById('grid-container');
const statusEl = document.getElementById('status');
const timerEl = document.getElementById('timer');
const sizeLabel = document.getElementById('size-label');

// ─── Adaptive Cell Sizing ──────────────────────────────────────────

function updateCellSize(size) {
  let cellPx, fontRem;
  if (size <= 7) { cellPx = 52; fontRem = 1.1; }
  else if (size <= 10) { cellPx = 42; fontRem = 1.0; }
  else if (size <= 15) { cellPx = 32; fontRem = 0.85; }
  else if (size <= 20) { cellPx = 26; fontRem = 0.75; }
  else { cellPx = 22; fontRem = 0.65; }

  // Also constrain to viewport width
  const maxWidth = Math.floor((window.innerWidth - 40) / size) - 1;
  cellPx = Math.min(cellPx, Math.max(16, maxWidth));

  document.documentElement.style.setProperty('--cell-size', cellPx + 'px');
  document.documentElement.style.setProperty('--cell-font', fontRem + 'rem');
}

// ─── Rendering ─────────────────────────────────────────────────────

function renderGrid() {
  const rows = grid.length;
  const cols = grid[0].length;

  updateCellSize(Math.max(rows, cols));

  gridEl.style.gridTemplateColumns = `repeat(${cols}, var(--cell-size))`;
  gridEl.style.gridTemplateRows = `repeat(${rows}, var(--cell-size))`;
  gridEl.innerHTML = '';

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell' + (grid[r][c] > 0 ? ' clue' : ' empty');
      cell.textContent = grid[r][c] > 0 ? grid[r][c] : '';
      cell.dataset.r = r;
      cell.dataset.c = c;
      gridEl.appendChild(cell);
    }
  }

  renderOverlays();
}

function renderOverlays() {
  gridContainer.querySelectorAll('.rect-overlay').forEach(el => el.remove());

  const cellSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size'));
  const gap = 1;
  const border = 2;

  for (let i = 0; i < playerRects.length; i++) {
    const { r1, c1, r2, c2, color } = playerRects[i];
    const overlay = document.createElement('div');
    overlay.className = 'rect-overlay';

    const x = border + c1 * (cellSize + gap);
    const y = border + r1 * (cellSize + gap);
    const w = (c2 - c1 + 1) * (cellSize + gap) - gap;
    const h = (r2 - r1 + 1) * (cellSize + gap) - gap;

    overlay.style.left = x + 'px';
    overlay.style.top = y + 'px';
    overlay.style.width = w + 'px';
    overlay.style.height = h + 'px';
    overlay.style.borderColor = color;
    overlay.style.background = color + '18';

    const valid = isRectValid(r1, c1, r2, c2, i);
    if (!valid) overlay.classList.add('invalid');

    gridContainer.appendChild(overlay);
  }
}

function isRectValid(r1, c1, r2, c2, selfIdx) {
  const area = (r2 - r1 + 1) * (c2 - c1 + 1);
  let clueCount = 0;
  let clueVal = 0;

  for (let r = r1; r <= r2; r++) {
    for (let c = c1; c <= c2; c++) {
      if (grid[r][c] > 0) {
        clueCount++;
        clueVal = grid[r][c];
      }
    }
  }

  if (clueCount !== 1 || clueVal !== area) return false;

  for (let i = 0; i < playerRects.length; i++) {
    if (i === selfIdx) continue;
    const o = playerRects[i];
    if (r1 <= o.r2 && r2 >= o.r1 && c1 <= o.c2 && c2 >= o.c1) return false;
  }

  return true;
}

function updateSelectionHighlight() {
  const cells = gridEl.querySelectorAll('.cell');
  cells.forEach(cell => cell.classList.remove('selecting'));

  if (!isDragging || !dragStart || !dragEnd) return;

  const r1 = Math.min(dragStart.r, dragEnd.r);
  const r2 = Math.max(dragStart.r, dragEnd.r);
  const c1 = Math.min(dragStart.c, dragEnd.c);
  const c2 = Math.max(dragStart.c, dragEnd.c);

  cells.forEach(cell => {
    const r = parseInt(cell.dataset.r);
    const c = parseInt(cell.dataset.c);
    if (r >= r1 && r <= r2 && c >= c1 && c <= c2) {
      cell.classList.add('selecting');
    }
  });
}

function checkWin() {
  if (solved) return;

  const rows = grid.length;
  const cols = grid[0].length;
  const covered = Array.from({ length: rows }, () => new Uint8Array(cols));

  for (let i = 0; i < playerRects.length; i++) {
    const { r1, c1, r2, c2 } = playerRects[i];
    if (!isRectValid(r1, c1, r2, c2, i)) return;

    for (let r = r1; r <= r2; r++)
      for (let c = c1; c <= c2; c++)
        covered[r][c] = 1;
  }

  for (let r = 0; r < rows; r++)
    for (let c = 0; c < cols; c++)
      if (!covered[r][c]) return;

  solved = true;
  clearInterval(timerInterval);
  statusEl.textContent = 'Solved! Well done!';
  statusEl.className = 'status win';
}

// ─── Input Handling ────────────────────────────────────────────────

function getCellFromEvent(e) {
  const touch = e.touches ? e.touches[0] : e;
  const el = document.elementFromPoint(touch.clientX, touch.clientY);
  if (el && el.classList.contains('cell')) {
    return { r: parseInt(el.dataset.r), c: parseInt(el.dataset.c) };
  }
  return null;
}

function onPointerDown(e) {
  if (solved) return;
  e.preventDefault();
  const cell = getCellFromEvent(e);
  if (!cell) return;

  isDragging = true;
  dragStart = cell;
  dragEnd = cell;

  if (!timerStart) {
    timerStart = Date.now();
    timerInterval = setInterval(updateTimer, 1000);
  }

  updateSelectionHighlight();
}

function onPointerMove(e) {
  if (!isDragging) return;
  e.preventDefault();
  const cell = getCellFromEvent(e);
  if (cell) {
    dragEnd = cell;
    updateSelectionHighlight();
  }
}

function onPointerUp(e) {
  if (!isDragging) return;
  isDragging = false;

  if (!dragStart || !dragEnd) {
    updateSelectionHighlight();
    return;
  }

  const r1 = Math.min(dragStart.r, dragEnd.r);
  const r2 = Math.max(dragStart.r, dragEnd.r);
  const c1 = Math.min(dragStart.c, dragEnd.c);
  const c2 = Math.max(dragStart.c, dragEnd.c);

  // Single cell click: remove any rect covering that cell
  if (r1 === r2 && c1 === c2) {
    for (let i = playerRects.length - 1; i >= 0; i--) {
      const o = playerRects[i];
      if (r1 >= o.r1 && r1 <= o.r2 && c1 >= o.c1 && c1 <= o.c2) {
        undoStack.push([...playerRects.map(r => ({ ...r }))]);
        playerRects.splice(i, 1);
        renderOverlays();
        updateStatus();
        updateSelectionHighlight();
        return;
      }
    }
    updateSelectionHighlight();
    return;
  }

  // Remove any overlapping rects
  undoStack.push([...playerRects.map(r => ({ ...r }))]);
  playerRects = playerRects.filter(o => {
    return !(r1 <= o.r2 && r2 >= o.r1 && c1 <= o.c2 && c2 >= o.c1);
  });

  const color = COLORS[playerRects.length % COLORS.length];
  playerRects.push({ r1, c1, r2, c2, color });

  renderOverlays();
  updateSelectionHighlight();
  updateStatus();
  checkWin();
}

function updateStatus() {
  if (solved) return;
  const rows = grid.length;
  const cols = grid[0].length;
  const totalCells = rows * cols;

  let coveredCount = 0;
  const covered = Array.from({ length: rows }, () => new Uint8Array(cols));
  for (const { r1, c1, r2, c2 } of playerRects) {
    for (let r = r1; r <= r2; r++)
      for (let c = c1; c <= c2; c++)
        if (!covered[r][c]) { covered[r][c] = 1; coveredCount++; }
  }

  const invalidCount = playerRects.filter((_, i) =>
    !isRectValid(playerRects[i].r1, playerRects[i].c1, playerRects[i].r2, playerRects[i].c2, i)
  ).length;

  if (playerRects.length === 0) {
    statusEl.textContent = 'Drag to draw rectangles. Each must contain exactly one number equal to its area.';
    statusEl.className = 'status';
  } else if (invalidCount > 0) {
    statusEl.textContent = `${playerRects.length} rectangles drawn, ${invalidCount} invalid. ${coveredCount}/${totalCells} cells covered.`;
    statusEl.className = 'status error';
  } else {
    statusEl.textContent = `${playerRects.length} rectangles drawn. ${coveredCount}/${totalCells} cells covered.`;
    statusEl.className = 'status';
  }
}

function updateTimer() {
  if (!timerStart) { timerEl.textContent = '0:00'; return; }
  const elapsed = Math.floor((Date.now() - timerStart) / 1000);
  const m = Math.floor(elapsed / 60);
  const s = elapsed % 60;
  timerEl.textContent = `${m}:${s.toString().padStart(2, '0')}`;
}

// ─── Custom Puzzle ─────────────────────────────────────────────────

const modalOverlay = document.getElementById('modal-overlay');
const customInput = document.getElementById('custom-input');
const customError = document.getElementById('custom-error');

function parseCustomGrid(text) {
  const lines = text.trim().split('\n').map(l => l.trim()).filter(l => l.length > 0);
  if (lines.length === 0) return { error: 'No input provided.' };

  const rows = [];
  for (const line of lines) {
    const nums = line.split(/[\s,]+/).map(Number);
    if (nums.some(isNaN)) return { error: `Invalid number in row: "${line}"` };
    if (nums.some(n => n < 0)) return { error: 'Negative numbers are not allowed.' };
    rows.push(nums);
  }

  const cols = rows[0].length;
  if (cols === 0) return { error: 'Empty row.' };
  if (cols > 25 || rows.length > 25) return { error: 'Maximum size is 25x25.' };

  for (let i = 0; i < rows.length; i++) {
    if (rows[i].length !== cols) {
      return { error: `Row ${i + 1} has ${rows[i].length} values, expected ${cols}.` };
    }
  }

  const clueSum = rows.reduce((s, row) => s + row.reduce((a, b) => a + b, 0), 0);
  const area = rows.length * cols;
  if (clueSum !== area) {
    return { error: `Clue sum (${clueSum}) must equal grid area (${area}).` };
  }

  return { grid: rows };
}

function loadCustomPuzzle(andSolve) {
  const parsed = parseCustomGrid(customInput.value);
  if (parsed.error) {
    customError.textContent = parsed.error;
    return;
  }

  customError.textContent = '';
  modalOverlay.classList.remove('visible');

  grid = parsed.grid;
  gridSize = Math.max(grid.length, grid[0].length);
  sizeLabel.textContent = `${grid[0].length}\u00d7${grid.length}`;
  playerRects = [];
  undoStack = [];
  solved = false;
  timerStart = null;
  clearInterval(timerInterval);
  timerEl.textContent = '0:00';
  statusEl.textContent = 'Custom puzzle loaded. ' + (andSolve ? 'Solving...' : 'Draw rectangles to solve.');
  statusEl.className = 'status';
  renderGrid();

  if (andSolve) {
    requestAnimationFrame(() => setTimeout(() => {
      const result = solveShikaku(grid);
      if (!result) {
        const reasons = diagnosePuzzle(grid);
        statusEl.textContent = 'No solution found: ' + reasons[0];
        statusEl.className = 'status error';
        console.warn('Puzzle diagnosis:', reasons);
        return;
      }
      playerRects = result.map(({ rect }, i) => ({
        r1: rect[0], c1: rect[1], r2: rect[2], c2: rect[3],
        color: COLORS[i % COLORS.length],
      }));
      renderOverlays();
      solved = true;
      statusEl.textContent = 'Solved!';
      statusEl.className = 'status win';
    }, 16));
  }
}

document.getElementById('btn-custom').addEventListener('click', () => {
  customError.textContent = '';
  modalOverlay.classList.add('visible');
});
document.getElementById('btn-custom-cancel').addEventListener('click', () => {
  modalOverlay.classList.remove('visible');
});
document.getElementById('btn-custom-load').addEventListener('click', () => loadCustomPuzzle(true));
document.getElementById('btn-custom-play').addEventListener('click', () => loadCustomPuzzle(false));
modalOverlay.addEventListener('click', (e) => {
  if (e.target === modalOverlay) modalOverlay.classList.remove('visible');
});

// ─── Controls ──────────────────────────────────────────────────────

document.getElementById('btn-new').addEventListener('click', newPuzzle);
document.getElementById('btn-undo').addEventListener('click', undo);
document.getElementById('btn-clear').addEventListener('click', clearRects);
document.getElementById('btn-solve').addEventListener('click', autoSolve);
document.getElementById('btn-smaller').addEventListener('click', () => changeSize(-1));
document.getElementById('btn-larger').addEventListener('click', () => changeSize(1));

function newPuzzle() {
  grid = generatePuzzle(gridSize, gridSize);
  playerRects = [];
  undoStack = [];
  solved = false;
  timerStart = null;
  clearInterval(timerInterval);
  timerEl.textContent = '0:00';
  statusEl.textContent = 'Drag to draw rectangles. Each must contain exactly one number equal to its area.';
  statusEl.className = 'status';
  renderGrid();
}

function undo() {
  if (undoStack.length === 0 || solved) return;
  playerRects = undoStack.pop();
  renderOverlays();
  updateStatus();
}

function clearRects() {
  if (playerRects.length === 0 || solved) return;
  undoStack.push([...playerRects.map(r => ({ ...r }))]);
  playerRects = [];
  renderOverlays();
  updateStatus();
}

function autoSolve() {
  statusEl.textContent = 'Solving...';
  statusEl.className = 'status';

  requestAnimationFrame(() => {
    setTimeout(() => {
      const result = solveShikaku(grid);
      if (!result) {
        const reasons = diagnosePuzzle(grid);
        statusEl.textContent = 'No solution found: ' + reasons[0];
        statusEl.className = 'status error';
        console.warn('Puzzle diagnosis:', reasons);
        return;
      }

      undoStack.push([...playerRects.map(r => ({ ...r }))]);
      playerRects = result.map(({ rect }, i) => ({
        r1: rect[0], c1: rect[1], r2: rect[2], c2: rect[3],
        color: COLORS[i % COLORS.length],
      }));

      renderOverlays();

      solved = true;
      clearInterval(timerInterval);
      if (!timerStart) timerStart = Date.now();
      updateTimer();
      statusEl.textContent = 'Solved by computer!';
      statusEl.className = 'status win';
    }, 16);
  });
}

function changeSize(delta) {
  gridSize = Math.max(3, Math.min(25, gridSize + delta));
  sizeLabel.textContent = `${gridSize}\u00d7${gridSize}`;
  newPuzzle();
}

// ─── Event Listeners ───────────────────────────────────────────────

gridEl.addEventListener('mousedown', onPointerDown);
document.addEventListener('mousemove', onPointerMove);
document.addEventListener('mouseup', onPointerUp);
gridEl.addEventListener('touchstart', onPointerDown, { passive: false });
document.addEventListener('touchmove', onPointerMove, { passive: false });
document.addEventListener('touchend', onPointerUp);
gridEl.addEventListener('contextmenu', e => e.preventDefault());

// ─── Self-Tests (run on load, output to console) ──────────────────

(function runTests() {
  let passed = 0, failed = 0;

  function assert(ok, msg) {
    if (ok) { passed++; }
    else { failed++; console.error('FAIL:', msg); }
  }

  function validateSolution(g, sol) {
    const rows = g.length, cols = g[0].length;
    const cov = Array.from({ length: rows }, () => new Int8Array(cols).fill(-1));
    for (let i = 0; i < sol.length; i++) {
      const { clue, rect } = sol[i];
      const [cr, cc, val] = clue;
      const [r1, c1, r2, c2] = rect;
      const area = (r2 - r1 + 1) * (c2 - c1 + 1);
      if (area !== val) return `rect ${i}: area ${area} != clue ${val}`;
      if (cr < r1 || cr > r2 || cc < c1 || cc > c2) return `rect ${i}: clue outside rect`;
      if (r1 < 0 || c1 < 0 || r2 >= rows || c2 >= cols) return `rect ${i}: out of bounds`;
      for (let r = r1; r <= r2; r++)
        for (let c = c1; c <= c2; c++) {
          if (g[r][c] > 0 && !(r === cr && c === cc)) return `rect ${i}: extra clue at (${r},${c})`;
          if (cov[r][c] !== -1) return `rect ${i}: overlaps rect ${cov[r][c]} at (${r},${c})`;
          cov[r][c] = i;
        }
    }
    for (let r = 0; r < rows; r++)
      for (let c = 0; c < cols; c++)
        if (cov[r][c] === -1) return `cell (${r},${c}) uncovered`;
    return null;
  }

  // Test 1: Solve known 5x5
  const p5 = [[0,6,0,0,4],[0,0,0,0,0],[0,0,5,0,0],[4,0,0,0,0],[0,0,0,6,0]];
  const s5 = solveShikaku(p5);
  assert(s5 !== null, '5x5: should find solution');
  if (s5) assert(validateSolution(p5, s5) === null, '5x5: ' + validateSolution(p5, s5));

  // Test 2: Solve known 6x6
  const p6 = [[6,0,0,0,0,0],[0,0,0,0,0,6],[0,6,0,0,0,0],[0,0,0,0,6,0],[0,0,0,6,0,0],[6,0,0,0,0,0]];
  const s6 = solveShikaku(p6);
  assert(s6 !== null, '6x6: should find solution');
  if (s6) assert(validateSolution(p6, s6) === null, '6x6: ' + validateSolution(p6, s6));

  // Test 3: Solve known 7x7
  const p7 = [[6,0,0,0,0,0,8],[0,0,0,0,0,0,0],[0,0,6,0,0,4,0],[0,0,0,4,0,0,0],[9,0,0,0,0,0,3],[0,0,0,0,6,0,0],[0,0,0,3,0,0,0]];
  const s7 = solveShikaku(p7);
  assert(s7 !== null, '7x7: should find solution');
  if (s7) assert(validateSolution(p7, s7) === null, '7x7: ' + validateSolution(p7, s7));

  // Test 4: Trivial 1x1
  const s1 = solveShikaku([[1]]);
  assert(s1 !== null, '1x1: should find solution');

  // Test 5: Simple 2x2
  const s2 = solveShikaku([[4,0],[0,0]]);
  assert(s2 !== null && s2.length === 1, '2x2: should have 1 rect');

  // Test 6: Reject bad clue sum
  assert(solveShikaku([[3,0],[0,0]]) === null, 'bad sum: should return null');

  // Test 7: Reject unsolvable
  assert(solveShikaku([[2,2],[0,0]]) === null, 'unsolvable: should return null');

  // Test 8: Generator produces valid grids with correct clue sums
  for (const sz of [3, 4, 5, 6, 7, 8, 10, 15]) {
    for (let t = 0; t < 3; t++) {
      const g = generatePuzzle(sz, sz);
      assert(g.length === sz && g[0].length === sz, `gen ${sz}x${sz}: wrong dimensions`);
      let sum = 0;
      for (let r = 0; r < sz; r++) for (let c = 0; c < sz; c++) sum += g[r][c];
      assert(sum === sz * sz, `gen ${sz}x${sz} trial ${t}: clue sum ${sum} != ${sz * sz}`);
    }
  }

  // Test 9: Generated puzzles are solvable (test small sizes)
  for (const sz of [3, 4, 5, 6, 7]) {
    for (let t = 0; t < 3; t++) {
      const g = generatePuzzle(sz, sz);
      const sol = solveShikaku(g);
      assert(sol !== null, `gen ${sz}x${sz} trial ${t}: should be solvable`);
      if (sol) {
        const err = validateSolution(g, sol);
        assert(err === null, `gen ${sz}x${sz} trial ${t}: ${err}`);
      }
    }
  }

  // Test 10: Custom puzzle parser
  const r1 = parseCustomGrid('0 6 0\n0 0 0\n3 0 0');
  assert(r1.grid && r1.grid.length === 3, 'parser: valid 3x3');

  const r2 = parseCustomGrid('1 2\n3');
  assert(r2.error, 'parser: reject uneven rows');

  const r3 = parseCustomGrid('');
  assert(r3.error, 'parser: reject empty');

  const r4 = parseCustomGrid('1 a\n0 0');
  assert(r4.error, 'parser: reject non-numbers');

  // Test 11: Diagnostics — bad clue sum
  const d1 = diagnosePuzzle([[3,0],[0,0]]);
  assert(d1.some(r => r.includes('Clue sum')), 'diag: detect bad clue sum');

  // Test 12: Diagnostics — clue too large
  const d2 = diagnosePuzzle([[9,0],[0,0]]);  // sum != area, caught first
  assert(d2.length > 0, 'diag: detect clue sum mismatch for oversized clue');

  // Test 13: Diagnostics — adjacent 1s
  const d3 = diagnosePuzzle([[1,1],[0,0]]);  // sum=2, area=4 → sum mismatch
  // try one that has correct sum
  const d4 = diagnosePuzzle([[1,1,1],[1,1,1]]);  // 6=6, but two adjacent 1s everywhere
  assert(d4.some(r => r.includes('adjacent')), 'diag: detect adjacent clues of 1');

  // Test 14: Diagnostics — no possible rects (clue value can't form rectangle in grid)
  const d5 = diagnosePuzzle([[7,0,0],[0,0,0]]);  // 7 in a 2x3=6 grid → sum wrong
  assert(d5.length > 0, 'diag: detect impossible clue');

  // Test 15: Diagnostics — valid puzzle returns no structural issues
  const d6 = diagnosePuzzle([[4,0],[0,0]]);
  assert(d6.some(r => r.includes('no solution') || r.includes('No obvious')), 'diag: valid puzzle has no structural issue');

  // Test 16: Diagnostics — clue blocked by other clues
  const d7 = diagnosePuzzle([[2,2],[2,0]]);  // sum=6, area=4 → sum mismatch
  assert(d7.length > 0, 'diag: detect sum mismatch');

  if (failed === 0) {
    console.log(`%cShikaku tests: all ${passed} passed`, 'color: #4ecdc4; font-weight: bold');
  } else {
    console.warn(`Shikaku tests: ${passed} passed, ${failed} FAILED`);
  }
})();

// ─── Init ──────────────────────────────────────────────────────────

newPuzzle();

</script>
</body>
</html>
