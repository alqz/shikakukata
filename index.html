<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Shikakukata — Shikaku Puzzle</title>
<link rel="stylesheet" href="style.css">
</head>
<body>

<h1>SHIKAKUKATA</h1>
<p class="subtitle">Shikaku Puzzle Game</p>

<div class="controls">
  <div class="size-controls">
    <button id="btn-smaller" aria-label="Decrease grid size">&minus;</button>
    <span id="size-label">5&times;5</span>
    <button id="btn-larger" aria-label="Increase grid size">+</button>
  </div>
  <button id="btn-new">New Puzzle</button>
  <button id="btn-custom">Custom</button>
  <button id="btn-edit">Edit Grid</button>
  <button id="btn-undo">Undo</button>
  <button id="btn-clear">Clear</button>
  <button id="btn-solve">Solve</button>
</div>

<div class="timer" id="timer">0:00</div>
<div class="status" id="status">Drag to draw rectangles. Each must contain exactly one number equal to its area.</div>

<div id="grid-container">
  <div id="grid" role="grid" aria-label="Shikaku puzzle grid"></div>
  <div id="selection-overlay"></div>
</div>

<div class="instructions">
  <strong>How to play:</strong> Drag to draw rectangles. Each must contain exactly
  <strong>one number</strong> equal to its <strong>area</strong>. Click a rectangle to remove it.
  Cover every cell to win.<br><br>
  <strong>Features:</strong>
  Grids up to 25&times;25 &middot;
  Auto-solver &middot;
  Paste your own puzzle via <strong>Custom</strong> &middot;
  Edit cells directly via <strong>Edit Grid</strong> &middot;
  Diagnostics for unsolvable puzzles<br>
  <a href="algorithm.html">How the solver algorithm works</a>
</div>

<!-- Custom puzzle modal -->
<div class="modal-overlay" id="modal-overlay">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modal-title">
    <h2 id="modal-title">Enter Custom Puzzle</h2>
    <p>
      Enter numbers separated by spaces, one row per line.
      Use <strong>0</strong> for empty cells. All rows must have the same length,
      and the clue values must sum to the total grid area.
    </p>
    <textarea id="custom-input" spellcheck="false" placeholder="0 6 0 0 4
0 0 0 0 0
0 0 5 0 0
4 0 0 0 0
0 0 0 6 0"></textarea>
    <div class="error-msg" id="custom-error"></div>
    <div class="modal-buttons">
      <button id="btn-custom-cancel">Cancel</button>
      <button id="btn-custom-load">Load &amp; Solve</button>
      <button id="btn-custom-play">Load &amp; Play</button>
    </div>
  </div>
</div>

<script src="solver.js"></script>
<script>
// ─── Game State ────────────────────────────────────────────────────

const COLORS = [
  '#e94560', '#4ecdc4', '#f7dc6f', '#a29bfe', '#fd79a8',
  '#00b894', '#6c5ce7', '#fdcb6e', '#e17055', '#74b9ff',
  '#55efc4', '#fab1a0', '#81ecec', '#dfe6e9', '#b2bec3',
  '#636e72', '#d63031', '#0984e3', '#e84393', '#00cec9',
  '#2d3436', '#ffeaa7', '#ff7675', '#a4b0be', '#f5cd79',
];

let gridSize = 5;
let grid = [];
let playerRects = [];
let undoStack = [];
let dragStart = null;
let dragEnd = null;
let isDragging = false;
let timerStart = null;
let timerInterval = null;
let solved = false;
let editMode = false;
let solving = false;
let activeEditInput = null;

const gridEl = document.getElementById('grid');
const gridContainer = document.getElementById('grid-container');
const statusEl = document.getElementById('status');
const timerEl = document.getElementById('timer');
const sizeLabel = document.getElementById('size-label');
const selectionOverlay = document.getElementById('selection-overlay');

// ─── Rendering ─────────────────────────────────────────────────────

let cellPool = [];
let poolRows = 0;
let poolCols = 0;

function getCellSize() {
  return parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-size'), 10);
}

function renderGrid() {
  const rows = grid.length;
  const cols = grid[0].length;
  const cellSize = getComputedStyle(document.documentElement).getPropertyValue('--cell-size').trim();

  gridEl.style.gridTemplateColumns = `repeat(${cols}, ${cellSize})`;
  gridEl.style.gridTemplateRows = `repeat(${rows}, ${cellSize})`;

  if (poolRows !== rows || poolCols !== cols) {
    cellPool = [];
    const fragment = document.createDocumentFragment();
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const cell = document.createElement('div');
        cell.dataset.r = r;
        cell.dataset.c = c;
        cellPool.push(cell);
        fragment.appendChild(cell);
      }
    }
    gridEl.replaceChildren(fragment);
    poolRows = rows;
    poolCols = cols;
  }

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const cell = cellPool[r * cols + c];
      const val = grid[r][c];
      if (editMode) {
        cell.className = 'cell editable' + (val > 0 ? ' clue' : '');
      } else {
        cell.className = 'cell' + (val > 0 ? ' clue' : ' empty');
      }
      cell.textContent = val > 0 ? val : '';
    }
  }

  renderOverlays();
}

function renderOverlays() {
  gridContainer.querySelectorAll('.rect-overlay').forEach(el => el.remove());

  const cellSize = getCellSize();
  const gap = 1;
  const border = 1;

  for (let i = 0; i < playerRects.length; i++) {
    const { r1, c1, r2, c2, color } = playerRects[i];
    const overlay = document.createElement('div');
    overlay.className = 'rect-overlay';

    const x = border + c1 * (cellSize + gap);
    const y = border + r1 * (cellSize + gap);
    const w = (c2 - c1 + 1) * (cellSize + gap) - gap;
    const h = (r2 - r1 + 1) * (cellSize + gap) - gap;

    overlay.style.left = x + 'px';
    overlay.style.top = y + 'px';
    overlay.style.width = w + 'px';
    overlay.style.height = h + 'px';
    overlay.style.borderColor = color;
    overlay.style.background = color + '18';

    const valid = isRectValid(r1, c1, r2, c2, i);
    if (!valid) overlay.classList.add('invalid');

    gridContainer.appendChild(overlay);
  }
}

function isRectValid(r1, c1, r2, c2, selfIdx) {
  const area = (r2 - r1 + 1) * (c2 - c1 + 1);
  let clueCount = 0;
  let clueVal = 0;

  for (let r = r1; r <= r2; r++) {
    for (let c = c1; c <= c2; c++) {
      if (grid[r][c] > 0) {
        clueCount++;
        clueVal = grid[r][c];
      }
    }
  }

  if (clueCount !== 1 || clueVal !== area) return false;

  for (let i = 0; i < playerRects.length; i++) {
    if (i === selfIdx) continue;
    const o = playerRects[i];
    if (r1 <= o.r2 && r2 >= o.r1 && c1 <= o.c2 && c2 >= o.c1) return false;
  }

  return true;
}

function updateSelectionHighlight() {
  if (!isDragging || !dragStart || !dragEnd) {
    selectionOverlay.style.display = 'none';
    return;
  }

  const cellSize = getCellSize();
  const gap = 1;
  const border = 1;

  const r1 = Math.min(dragStart.r, dragEnd.r);
  const r2 = Math.max(dragStart.r, dragEnd.r);
  const c1 = Math.min(dragStart.c, dragEnd.c);
  const c2 = Math.max(dragStart.c, dragEnd.c);

  const x = border + c1 * (cellSize + gap);
  const y = border + r1 * (cellSize + gap);
  const w = (c2 - c1 + 1) * (cellSize + gap) - gap;
  const h = (r2 - r1 + 1) * (cellSize + gap) - gap;

  selectionOverlay.style.left = x + 'px';
  selectionOverlay.style.top = y + 'px';
  selectionOverlay.style.width = w + 'px';
  selectionOverlay.style.height = h + 'px';
  selectionOverlay.style.display = 'block';
}

function checkWin() {
  if (solved) return;

  const rows = grid.length;
  const cols = grid[0].length;
  const covered = Array.from({ length: rows }, () => new Uint8Array(cols));

  for (let i = 0; i < playerRects.length; i++) {
    const { r1, c1, r2, c2 } = playerRects[i];
    if (!isRectValid(r1, c1, r2, c2, i)) return;

    for (let r = r1; r <= r2; r++)
      for (let c = c1; c <= c2; c++)
        covered[r][c] = 1;
  }

  for (let r = 0; r < rows; r++)
    for (let c = 0; c < cols; c++)
      if (!covered[r][c]) return;

  solved = true;
  clearInterval(timerInterval);
  statusEl.textContent = 'Solved! Well done!';
  statusEl.className = 'status win';
}

// ─── Input Handling ────────────────────────────────────────────────

function getCellFromEvent(e) {
  const touch = e.touches ? e.touches[0] : e;
  const el = document.elementFromPoint(touch.clientX, touch.clientY);
  if (el && el.classList.contains('cell')) {
    return { r: +el.dataset.r, c: +el.dataset.c };
  }
  return null;
}

function onPointerDown(e) {
  if (solved || editMode) return;
  e.preventDefault();
  const cell = getCellFromEvent(e);
  if (!cell) return;

  isDragging = true;
  dragStart = cell;
  dragEnd = cell;

  if (!timerStart) {
    timerStart = Date.now();
    timerInterval = setInterval(updateTimer, 1000);
  }

  updateSelectionHighlight();
}

function onPointerMove(e) {
  if (!isDragging) return;
  e.preventDefault();
  const cell = getCellFromEvent(e);
  if (cell) {
    dragEnd = cell;
    updateSelectionHighlight();
  }
}

function onPointerUp(e) {
  if (!isDragging) return;
  isDragging = false;

  if (!dragStart || !dragEnd) {
    updateSelectionHighlight();
    return;
  }

  const r1 = Math.min(dragStart.r, dragEnd.r);
  const r2 = Math.max(dragStart.r, dragEnd.r);
  const c1 = Math.min(dragStart.c, dragEnd.c);
  const c2 = Math.max(dragStart.c, dragEnd.c);

  // Single cell click: remove any rect covering that cell
  if (r1 === r2 && c1 === c2) {
    for (let i = playerRects.length - 1; i >= 0; i--) {
      const o = playerRects[i];
      if (r1 >= o.r1 && r1 <= o.r2 && c1 >= o.c1 && c1 <= o.c2) {
        undoStack.push([...playerRects.map(r => ({ ...r }))]);
        playerRects.splice(i, 1);
        renderOverlays();
        updateStatus();
        updateSelectionHighlight();
        return;
      }
    }
    updateSelectionHighlight();
    return;
  }

  // Remove any overlapping rects
  undoStack.push([...playerRects.map(r => ({ ...r }))]);
  playerRects = playerRects.filter(o => {
    return !(r1 <= o.r2 && r2 >= o.r1 && c1 <= o.c2 && c2 >= o.c1);
  });

  const color = COLORS[playerRects.length % COLORS.length];
  playerRects.push({ r1, c1, r2, c2, color });

  renderOverlays();
  updateSelectionHighlight();
  updateStatus();
  checkWin();
}

function updateStatus() {
  if (solved) return;
  const rows = grid.length;
  const cols = grid[0].length;
  const totalCells = rows * cols;

  let coveredCount = 0;
  const covered = Array.from({ length: rows }, () => new Uint8Array(cols));
  for (const { r1, c1, r2, c2 } of playerRects) {
    for (let r = r1; r <= r2; r++)
      for (let c = c1; c <= c2; c++)
        if (!covered[r][c]) { covered[r][c] = 1; coveredCount++; }
  }

  const invalidCount = playerRects.filter((_, i) =>
    !isRectValid(playerRects[i].r1, playerRects[i].c1, playerRects[i].r2, playerRects[i].c2, i)
  ).length;

  if (playerRects.length === 0) {
    statusEl.textContent = 'Drag to draw rectangles. Each must contain exactly one number equal to its area.';
    statusEl.className = 'status';
  } else if (invalidCount > 0) {
    statusEl.textContent = `${playerRects.length} rectangles drawn, ${invalidCount} invalid. ${coveredCount}/${totalCells} cells covered.`;
    statusEl.className = 'status error';
  } else {
    statusEl.textContent = `${playerRects.length} rectangles drawn. ${coveredCount}/${totalCells} cells covered.`;
    statusEl.className = 'status';
  }
}

function updateTimer() {
  if (!timerStart) { timerEl.textContent = '0:00'; return; }
  const elapsed = Math.floor((Date.now() - timerStart) / 1000);
  const m = Math.floor(elapsed / 60);
  const s = elapsed % 60;
  timerEl.textContent = `${m}:${s.toString().padStart(2, '0')}`;
}

// ─── Custom Puzzle ─────────────────────────────────────────────────

const modalOverlay = document.getElementById('modal-overlay');
const customInput = document.getElementById('custom-input');
const customError = document.getElementById('custom-error');

function openModal() {
  customError.textContent = '';
  modalOverlay.classList.add('visible');
  customInput.focus();
}

function closeModal() {
  modalOverlay.classList.remove('visible');
  document.getElementById('btn-custom').focus();
}

function loadCustomPuzzle(andSolve) {
  const parsed = parseCustomGrid(customInput.value);
  if (parsed.error) {
    customError.textContent = parsed.error;
    return;
  }

  customError.textContent = '';
  closeModal();

  grid = parsed.grid;
  gridSize = Math.max(grid.length, grid[0].length);
  sizeLabel.textContent = `${grid[0].length}\u00d7${grid.length}`;
  playerRects = [];
  undoStack = [];
  solved = false;
  timerStart = null;
  clearInterval(timerInterval);
  timerEl.textContent = '0:00';
  statusEl.textContent = 'Custom puzzle loaded. ' + (andSolve ? 'Solving...' : 'Draw rectangles to solve.');
  statusEl.className = 'status';
  renderGrid();

  if (andSolve) {
    solving = true;
    const solveStart = Date.now();
    const dots = ['Solving.', 'Solving..', 'Solving...'];
    let dotIdx = 0;
    const animInterval = setInterval(() => {
      const elapsed = ((Date.now() - solveStart) / 1000).toFixed(0);
      statusEl.textContent = `${dots[dotIdx++ % 3]} (${elapsed}s)`;
    }, 400);

    solveShikakuAsync(grid, () => {}).then(result => {
      clearInterval(animInterval);
      solving = false;
      const elapsed = ((Date.now() - solveStart) / 1000).toFixed(1);
      if (!result) {
        const reasons = diagnosePuzzle(grid);
        statusEl.textContent = `No solution found (${elapsed}s): ${reasons[0]}`;
        statusEl.className = 'status error';
        console.warn('Puzzle diagnosis:', reasons);
        return;
      }
      playerRects = result.map(({ rect }, i) => ({
        r1: rect[0], c1: rect[1], r2: rect[2], c2: rect[3],
        color: COLORS[i % COLORS.length],
      }));
      renderOverlays();
      solved = true;
      statusEl.textContent = `Solved in ${elapsed}s!`;
      statusEl.className = 'status win';
    });
  }
}

document.getElementById('btn-custom').addEventListener('click', openModal);
document.getElementById('btn-custom-cancel').addEventListener('click', closeModal);
document.getElementById('btn-custom-load').addEventListener('click', () => loadCustomPuzzle(true));
document.getElementById('btn-custom-play').addEventListener('click', () => loadCustomPuzzle(false));
modalOverlay.addEventListener('click', (e) => {
  if (e.target === modalOverlay) closeModal();
});

// ─── Controls ──────────────────────────────────────────────────────

document.getElementById('btn-new').addEventListener('click', newPuzzle);
document.getElementById('btn-edit').addEventListener('click', toggleEditMode);
document.getElementById('btn-undo').addEventListener('click', undo);
document.getElementById('btn-clear').addEventListener('click', clearRects);
document.getElementById('btn-solve').addEventListener('click', autoSolve);
document.getElementById('btn-smaller').addEventListener('click', () => changeSize(-1));
document.getElementById('btn-larger').addEventListener('click', () => changeSize(1));

function newPuzzle() {
  grid = generatePuzzle(gridSize, gridSize);
  playerRects = [];
  undoStack = [];
  solved = false;
  timerStart = null;
  clearInterval(timerInterval);
  timerEl.textContent = '0:00';
  statusEl.textContent = 'Drag to draw rectangles. Each must contain exactly one number equal to its area.';
  statusEl.className = 'status';
  renderGrid();
}

function undo() {
  if (undoStack.length === 0 || solved) return;
  playerRects = undoStack.pop();
  renderOverlays();
  updateStatus();
}

function clearRects() {
  if (playerRects.length === 0 || solved) return;
  undoStack.push([...playerRects.map(r => ({ ...r }))]);
  playerRects = [];
  renderOverlays();
  updateStatus();
}

async function autoSolve() {
  if (solving) return;
  solving = true;
  const solveStart = Date.now();
  statusEl.textContent = 'Solving...';
  statusEl.className = 'status';

  const dots = ['Solving.', 'Solving..', 'Solving...'];
  let dotIdx = 0;
  const animInterval = setInterval(() => {
    const elapsed = ((Date.now() - solveStart) / 1000).toFixed(0);
    statusEl.textContent = `${dots[dotIdx++ % 3]} (${elapsed}s)`;
  }, 400);

  const result = await solveShikakuAsync(grid, () => {});

  clearInterval(animInterval);
  solving = false;
  const elapsed = ((Date.now() - solveStart) / 1000).toFixed(1);

  if (!result) {
    const reasons = diagnosePuzzle(grid);
    statusEl.textContent = `No solution found (${elapsed}s): ${reasons[0]}`;
    statusEl.className = 'status error';
    console.warn('Puzzle diagnosis:', reasons);
    return;
  }

  undoStack.push([...playerRects.map(r => ({ ...r }))]);
  playerRects = result.map(({ rect }, i) => ({
    r1: rect[0], c1: rect[1], r2: rect[2], c2: rect[3],
    color: COLORS[i % COLORS.length],
  }));

  renderOverlays();

  solved = true;
  clearInterval(timerInterval);
  if (!timerStart) timerStart = Date.now();
  updateTimer();
  statusEl.textContent = `Solved by computer in ${elapsed}s!`;
  statusEl.className = 'status win';
}

function changeSize(delta) {
  gridSize = Math.max(3, Math.min(25, gridSize + delta));
  sizeLabel.textContent = `${gridSize}\u00d7${gridSize}`;
  newPuzzle();
}

// ─── Edit Mode ─────────────────────────────────────────────────────

function toggleEditMode() {
  if (solving) return;
  editMode = !editMode;
  const btn = document.getElementById('btn-edit');
  if (editMode) {
    btn.classList.add('active');
    playerRects = [];
    undoStack = [];
    solved = false;
    timerStart = null;
    clearInterval(timerInterval);
    timerEl.textContent = '0:00';
    statusEl.textContent = 'Edit mode: click cells to set clue numbers (0 to clear). Click "Edit Grid" again when done.';
    statusEl.className = 'status';
    renderGrid();
  } else {
    btn.classList.remove('active');
    commitEditInput();
    const rows = grid.length;
    const cols = grid[0].length;
    let clueSum = 0;
    for (let r = 0; r < rows; r++)
      for (let c = 0; c < cols; c++)
        clueSum += grid[r][c];
    const area = rows * cols;
    if (clueSum === 0) {
      statusEl.textContent = 'Grid has no clues. Add numbers or generate a new puzzle.';
      statusEl.className = 'status error';
    } else if (clueSum !== area) {
      statusEl.textContent = `Clue sum (${clueSum}) does not equal grid area (${area}). Puzzle may not be solvable.`;
      statusEl.className = 'status error';
    } else {
      statusEl.textContent = 'Custom puzzle ready. Draw rectangles to solve, or press Solve.';
      statusEl.className = 'status';
    }
    renderGrid();
  }
}

function commitEditInput() {
  if (!activeEditInput) return;
  const input = activeEditInput;
  activeEditInput = null;
  const r = +input.dataset.r;
  const c = +input.dataset.c;
  const val = parseInt(input.value, 10);
  grid[r][c] = (isNaN(val) || val < 0) ? 0 : val;
  renderGrid();
}

function onEditCellClick(e) {
  if (!editMode) return;
  const el = e.target.closest('.cell');
  if (!el || el.querySelector('.cell-input')) return;

  commitEditInput();

  const r = +el.dataset.r;
  const c = +el.dataset.c;

  const input = document.createElement('input');
  input.type = 'number';
  input.className = 'cell-input';
  input.value = grid[r][c] > 0 ? grid[r][c] : '';
  input.min = '0';
  input.dataset.r = r;
  input.dataset.c = c;

  el.textContent = '';
  el.appendChild(input);
  activeEditInput = input;

  input.focus();
  input.select();

  input.addEventListener('blur', commitEditInput);
  input.addEventListener('keydown', (evt) => {
    if (evt.key === 'Enter') input.blur();
    if (evt.key === 'Escape') { activeEditInput = null; renderGrid(); }
  });

  e.stopPropagation();
}

gridEl.addEventListener('click', onEditCellClick);

// ─── Keyboard Shortcuts ────────────────────────────────────────────

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    if (modalOverlay.classList.contains('visible')) {
      closeModal();
    }
    if (activeEditInput) {
      activeEditInput = null;
      renderGrid();
    }
  }
  if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
    e.preventDefault();
    undo();
  }
});

// ─── Event Listeners ───────────────────────────────────────────────

gridEl.addEventListener('mousedown', onPointerDown);
document.addEventListener('mousemove', onPointerMove);
document.addEventListener('mouseup', onPointerUp);
gridEl.addEventListener('touchstart', onPointerDown, { passive: false });
document.addEventListener('touchmove', onPointerMove, { passive: false });
document.addEventListener('touchend', onPointerUp);
gridEl.addEventListener('contextmenu', e => e.preventDefault());

// ─── Self-Tests (run on load, output to console) ──────────────────

(function runTests() {
  let passed = 0, failed = 0;

  function assert(ok, msg) {
    if (ok) { passed++; }
    else { failed++; console.error('FAIL:', msg); }
  }

  function validateSolution(g, sol) {
    const rows = g.length, cols = g[0].length;
    const cov = Array.from({ length: rows }, () => new Int8Array(cols).fill(-1));
    for (let i = 0; i < sol.length; i++) {
      const { clue, rect } = sol[i];
      const [cr, cc, val] = clue;
      const [r1, c1, r2, c2] = rect;
      const area = (r2 - r1 + 1) * (c2 - c1 + 1);
      if (area !== val) return `rect ${i}: area ${area} != clue ${val}`;
      if (cr < r1 || cr > r2 || cc < c1 || cc > c2) return `rect ${i}: clue outside rect`;
      if (r1 < 0 || c1 < 0 || r2 >= rows || c2 >= cols) return `rect ${i}: out of bounds`;
      for (let r = r1; r <= r2; r++)
        for (let c = c1; c <= c2; c++) {
          if (g[r][c] > 0 && !(r === cr && c === cc)) return `rect ${i}: extra clue at (${r},${c})`;
          if (cov[r][c] !== -1) return `rect ${i}: overlaps rect ${cov[r][c]} at (${r},${c})`;
          cov[r][c] = i;
        }
    }
    for (let r = 0; r < rows; r++)
      for (let c = 0; c < cols; c++)
        if (cov[r][c] === -1) return `cell (${r},${c}) uncovered`;
    return null;
  }

  // Test 1: Solve known 5x5
  const p5 = [[0,6,0,0,4],[0,0,0,0,0],[0,0,5,0,0],[4,0,0,0,0],[0,0,0,6,0]];
  const s5 = solveShikaku(p5);
  assert(s5 !== null, '5x5: should find solution');
  if (s5) assert(validateSolution(p5, s5) === null, '5x5: ' + validateSolution(p5, s5));

  // Test 2: Solve known 6x6
  const p6 = [[6,0,0,0,0,0],[0,0,0,0,0,6],[0,6,0,0,0,0],[0,0,0,0,6,0],[0,0,0,6,0,0],[6,0,0,0,0,0]];
  const s6 = solveShikaku(p6);
  assert(s6 !== null, '6x6: should find solution');
  if (s6) assert(validateSolution(p6, s6) === null, '6x6: ' + validateSolution(p6, s6));

  // Test 3: Solve known 7x7
  const p7 = [[6,0,0,0,0,0,8],[0,0,0,0,0,0,0],[0,0,6,0,0,4,0],[0,0,0,4,0,0,0],[9,0,0,0,0,0,3],[0,0,0,0,6,0,0],[0,0,0,3,0,0,0]];
  const s7 = solveShikaku(p7);
  assert(s7 !== null, '7x7: should find solution');
  if (s7) assert(validateSolution(p7, s7) === null, '7x7: ' + validateSolution(p7, s7));

  // Test 4: Trivial 1x1
  const s1 = solveShikaku([[1]]);
  assert(s1 !== null, '1x1: should find solution');

  // Test 5: Simple 2x2
  const s2 = solveShikaku([[4,0],[0,0]]);
  assert(s2 !== null && s2.length === 1, '2x2: should have 1 rect');

  // Test 6: Reject bad clue sum
  assert(solveShikaku([[3,0],[0,0]]) === null, 'bad sum: should return null');

  // Test 7: [[2,2],[0,0]] is actually solvable (two 2x1 rects side by side)
  const s2x2b = solveShikaku([[2,2],[0,0]]);
  assert(s2x2b !== null && s2x2b.length === 2, '2x2 two-clue: should have 2 rects');

  // Test 7b: Truly unsolvable — clue 3 in a 2x2 can't form a 1x3 or 3x1
  assert(solveShikaku([[3,0],[0,1]]) === null, 'unsolvable: should return null');

  // Test 8: Generator produces valid grids with correct clue sums
  for (const sz of [3, 4, 5, 6, 7, 8, 10, 15]) {
    for (let t = 0; t < 3; t++) {
      const g = generatePuzzle(sz, sz);
      assert(g.length === sz && g[0].length === sz, `gen ${sz}x${sz}: wrong dimensions`);
      let sum = 0;
      for (let r = 0; r < sz; r++) for (let c = 0; c < sz; c++) sum += g[r][c];
      assert(sum === sz * sz, `gen ${sz}x${sz} trial ${t}: clue sum ${sum} != ${sz * sz}`);
    }
  }

  // Test 9: Generated puzzles are solvable (test small sizes)
  for (const sz of [3, 4, 5, 6, 7]) {
    for (let t = 0; t < 3; t++) {
      const g = generatePuzzle(sz, sz);
      const sol = solveShikaku(g);
      assert(sol !== null, `gen ${sz}x${sz} trial ${t}: should be solvable`);
      if (sol) {
        const err = validateSolution(g, sol);
        assert(err === null, `gen ${sz}x${sz} trial ${t}: ${err}`);
      }
    }
  }

  // Test 10: Custom puzzle parser
  const r1 = parseCustomGrid('0 6 0\n0 0 0\n3 0 0');
  assert(r1.grid && r1.grid.length === 3, 'parser: valid 3x3');

  const r2 = parseCustomGrid('1 2\n3');
  assert(r2.error, 'parser: reject uneven rows');

  const r3 = parseCustomGrid('');
  assert(r3.error, 'parser: reject empty');

  const r4 = parseCustomGrid('1 a\n0 0');
  assert(r4.error, 'parser: reject non-numbers');

  // Test: trailing commas/spaces should not add ghost columns
  const r5 = parseCustomGrid('4, 0,\n0, 0,');
  assert(r5.grid && r5.grid[0].length === 2, 'parser: trailing comma ignored');

  const r6 = parseCustomGrid('4 0 \n0 0 ');
  assert(r6.grid && r6.grid[0].length === 2, 'parser: trailing space ignored');

  // ── Diagnostics tests ──

  // Test 11: bad clue sum
  const d1 = diagnosePuzzle([[3,0],[0,0]]);
  assert(d1.some(r => r.includes('Clue sum')), 'diag: detect bad clue sum');

  // Test 12: clue sum too large
  const d2 = diagnosePuzzle([[9,0],[0,0]]);
  assert(d2.some(r => r.includes('Clue sum')), 'diag: detect oversized clue sum');

  // Test 13: no clues at all
  const d_none = diagnosePuzzle([[0,0],[0,0]]);
  assert(d_none.some(r => r.includes('no clues')), 'diag: detect no clues');

  // Test 15: valid solvable puzzle — should say "no obvious structural issue"
  const d6 = diagnosePuzzle([[4,0],[0,0]]);
  assert(d6.some(r => r.includes('No obvious')), 'diag: valid puzzle reports no structural issue');

  // Test 16: clue that can't form any rectangle on grid
  const d_nofit = diagnosePuzzle([[3,0],[0,1]]);
  assert(d_nofit.some(r => r.includes('no possible rectangle')), 'diag: detect clue with no fitting rect');

  // Test 17: clue blocked by other clues
  // [[1,2,1,0,1]]: clue 2 at (0,1) — its only rects (1x2) each contain another clue
  const d_blocked = diagnosePuzzle([[1,2,1,0,1]]);
  assert(d_blocked.some(r => r.includes('every possible rectangle contains another clue')),
    'diag: detect clue blocked by neighbors');

  // Test 18: unreachable cells
  const d_reach = diagnosePuzzle([[4,0,0],[0,0,0],[0,0,5]]);
  assert(d_reach.some(r => r.includes('no possible rectangle') || r.includes('cannot be reached')),
    'diag: detect unreachable cells or impossible rect');

  // Test 19: diagnosePuzzle returns array
  assert(Array.isArray(d1), 'diag: returns array');
  assert(d1.length >= 1, 'diag: returns at least one reason');

  // Test 20: all reasons are strings
  for (const reasons of [d1, d_none, d6, d_nofit]) {
    assert(reasons.every(r => typeof r === 'string'), 'diag: all reasons are strings');
  }

  if (failed === 0) {
    console.log(`%cShikaku tests: all ${passed} passed`, 'color: #4ecdc4; font-weight: bold');
  } else {
    console.warn(`Shikaku tests: ${passed} passed, ${failed} FAILED`);
  }
})();

// ─── Init ──────────────────────────────────────────────────────────

newPuzzle();

</script>
</body>
</html>
