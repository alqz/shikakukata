<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Shikakukata â€” How the Solver Works</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: system-ui, -apple-system, sans-serif;
    background: #111;
    color: #d4d4d4;
    line-height: 1.7;
    padding: 48px 24px 80px;
    max-width: 780px;
    margin: 0 auto;
    user-select: text;
  }
  a { color: #e94560; text-decoration: none; }
  a:hover { text-decoration: underline; }
  .back { font-size: 0.85rem; display: inline-block; margin-bottom: 32px; color: #888; }
  .back:hover { color: #e94560; }
  h1 { font-size: 1.8rem; font-weight: 600; color: #e94560; margin-bottom: 4px; letter-spacing: 1px; }
  .subtitle { font-size: 0.95rem; color: #666; margin-bottom: 40px; }
  h2 { font-size: 1.2rem; font-weight: 600; color: #eee; margin: 40px 0 12px; }
  h3 { font-size: 1rem; font-weight: 500; color: #bbb; margin: 24px 0 8px; }
  p { font-size: 0.92rem; margin-bottom: 14px; }
  ul, ol { padding-left: 24px; margin-bottom: 16px; }
  li { font-size: 0.92rem; margin-bottom: 6px; }
  code {
    background: #1e1e1e;
    color: #f7dc6f;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 0.85rem;
  }
  pre {
    background: #1a1a1a;
    border: 1px solid #2a2a2a;
    border-radius: 4px;
    padding: 16px 20px;
    overflow-x: auto;
    font-size: 0.85rem;
    color: #ccc;
    line-height: 1.6;
    margin-bottom: 18px;
  }
  strong { color: #eee; font-weight: 600; }
  em { color: #ccc; }
  .footer { margin-top: 48px; padding-top: 24px; border-top: 1px solid #222; }
</style>
</head>
<body>

<a href="index.html" class="back">&larr; Back to game</a>
<h1>SHIKAKUKATA</h1>
<p class="subtitle">How the Solver Algorithm Works</p>

<h2>The Puzzle</h2>
<p>
  Shikaku is a logic puzzle played on a rectangular grid. Some cells contain numbers (clues).
  The goal is to divide the entire grid into non-overlapping rectangles such that each rectangle
  contains <strong>exactly one clue</strong>, and that clue's value equals the rectangle's <strong>area</strong>.
</p>
<p>
  Shikaku is NP-complete in general, meaning there's no known polynomial-time algorithm that
  solves all instances. Our solver uses backtracking search with several optimizations that make
  it fast in practice for typical puzzle sizes.
</p>

<h2>Step 1: Rectangle Enumeration</h2>
<p>
  For each clue with value <code>v</code> at position <code>(r, c)</code>, we enumerate every
  possible rectangle that:
</p>
<ol>
  <li>Has area exactly equal to <code>v</code></li>
  <li>Contains the cell <code>(r, c)</code></li>
  <li>Fits within the grid boundaries</li>
</ol>
<p>
  We do this by iterating over all factor pairs of <code>v</code>. For each pair
  <code>(h, w)</code> where <code>h &times; w = v</code>, we slide an <code>h &times; w</code>
  window across all positions that include <code>(r, c)</code>:
</p>
<pre>for h from 1 to v:
    if v is not divisible by h: skip
    w = v / h
    for r1 from (r - h + 1) to r:
        for c1 from (c - w + 1) to c:
            r2 = r1 + h - 1
            c2 = c1 + w - 1
            if rectangle (r1, c1, r2, c2) is within grid:
                add to candidate list</pre>

<h2>Step 2: Pre-filtering</h2>
<p>
  Before the search begins, we remove candidate rectangles that <strong>contain another clue</strong>.
  Since each rectangle must contain exactly one clue, any rectangle overlapping a second clue is
  immediately invalid. This is done once upfront, saving many checks during backtracking.
</p>
<p>
  The amount filtered depends on clue density &mdash; denser grids see more candidates eliminated.
</p>

<h2>Step 3: Backtracking Search</h2>
<p>
  The solver uses depth-first backtracking. At each step it:
</p>
<ol>
  <li>Picks an unplaced clue</li>
  <li>Tries each of that clue's candidate rectangles</li>
  <li>If a placement is valid (no overlap with already-placed rectangles), places it and recurses</li>
  <li>If the recursion fails, undoes the placement and tries the next candidate</li>
  <li>If all candidates are exhausted, backtracks to the previous clue</li>
</ol>

<h3>What makes a placement valid?</h3>
<p>
  A rectangle can be placed if every cell it covers is currently uncovered (not occupied by
  a previously placed rectangle). We check this with a <code>covered</code> grid that tracks
  which clue index occupies each cell, or <code>-1</code> for uncovered.
</p>

<h2>Step 4: Dynamic MRV Ordering</h2>
<p>
  The order in which we pick clues to place matters enormously. We use the
  <strong>Minimum Remaining Values (MRV)</strong> heuristic: at each step, pick the unplaced
  clue with the <em>fewest</em> valid (non-overlapping) rectangles remaining.
</p>
<p>
  The intuition: a clue with only 1 or 2 remaining options is highly constrained &mdash; if we delay it,
  we'll explore many branches that ultimately fail at that clue. By handling it first, we prune
  the search tree early.
</p>
<p>
  Crucially, our MRV is <strong>dynamic</strong> &mdash; we recompute remaining options at every step,
  not just once at the start. As rectangles are placed and cells become covered, remaining options
  for other clues shrink. This adaptive ordering can reduce the search tree by orders of magnitude
  compared to a static ordering.
</p>

<p>
  <strong>Static MRV</strong> fixes the pick order at the start. A clue that becomes
  heavily constrained mid-search may not be tried until much later, wasting effort on
  doomed branches.
</p>
<p>
  <strong>Dynamic MRV</strong> re-evaluates at each step:
</p>
<ol>
  <li>Clue C (2 options) &mdash; most constrained, try first</li>
  <li>Clue A (1 option) &mdash; after placing C, A is forced</li>
  <li>Clue B (3 options) &mdash; least constrained, easy to resolve last</li>
</ol>

<h2>Step 5: Forward Checking</h2>
<p>
  After each placement, before recursing deeper, we check whether a solution is still possible.
  Forward checking verifies two things:
</p>
<ol>
  <li>
    <strong>Clue feasibility:</strong> every unplaced clue still has at least one valid rectangle
    (one that doesn't overlap any placed rectangles). If any clue has zero options, we can
    immediately backtrack without exploring further.
  </li>
  <li>
    <strong>Dead cell detection:</strong> every uncovered cell is reachable by at least one
    remaining valid rectangle from some unplaced clue. If a cell is "orphaned" &mdash; no
    remaining clue can possibly reach it &mdash; the current partial solution can never lead
    to a complete covering.
  </li>
</ol>
<p>
  Together these checks catch many dead-end branches early. The cost of checking is modest
  compared to the branches it prunes.
</p>

<h2>Step 6: Async Chunking</h2>
<p>
  For the interactive solver (the "Solve" button), the algorithm runs asynchronously using
  <strong>chunked execution</strong>. The backtracker uses an explicit stack instead of the
  call stack, and after every 5,000 iterations, yields control back to the browser via
  <code>setTimeout(0)</code>. This keeps the UI responsive &mdash; the "Solving..." animation
  and timer continue to update even during long solves.
</p>

<h2>Puzzle Generation</h2>
<p>
  The generator creates puzzles by partitioning the grid into random rectangles, then placing
  a clue (equal to the rectangle's area) at a random position within each rectangle.
</p>
<ol>
  <li>Find the first uncovered cell (scanning left-to-right, top-to-bottom)</li>
  <li>Enumerate all rectangles anchored at that cell that fit on the grid</li>
  <li>Randomly select one (preferring medium-sized rectangles for interesting puzzles)</li>
  <li>Mark those cells as used and record the rectangle</li>
  <li>Repeat until the entire grid is covered</li>
</ol>
<p>
  Because the generator builds a valid partition directly, every generated puzzle is guaranteed
  to have at least one solution.
</p>

<h2>Diagnostics</h2>
<p>
  When the solver finds no solution, a diagnostic pass analyzes the puzzle to explain why:
</p>
<ul>
  <li><strong>Clue sum mismatch:</strong> the sum of all clue values doesn't equal the grid area</li>
  <li><strong>Impossible clues:</strong> a clue whose value has no factorization fitting on the grid</li>
  <li><strong>Blocked clues:</strong> every possible rectangle for a clue contains another clue</li>
  <li><strong>Unreachable cells:</strong> cells that no clue's rectangle can possibly cover</li>
</ul>

<h2>Complexity</h2>
<p>
  In the worst case, the solver explores an exponential number of branches. For a grid with
  <code>k</code> clues, each having up to <code>m</code> candidate rectangles, the worst-case
  search space is <code>O(m<sup>k</sup>)</code>. However, the optimizations above (pre-filtering,
  dynamic MRV, forward checking, dead cell detection) typically reduce the effective branching
  factor dramatically, making most puzzles solvable in well under a second up to about 15&times;15,
  and in a few seconds for larger grids.
</p>

<div class="footer">
  <a href="index.html">&larr; Back to game</a>
</div>

</body>
</html>
